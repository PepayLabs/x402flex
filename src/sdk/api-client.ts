export const DEFAULT_API_BASE_URL = 'https://api.bnbpay.org';

export type NetworkKey = 'bnb' | 'bnbTestnet';

export interface NetworkConfig {
  key: NetworkKey;
  chainId: number;
  name: string;
  registry: string;
  router: string;
  sessionStore: string;
  permit2: string;
  permit2WitnessTypeString: string;
  permit2WitnessMode: 'struct_hash';
}

export interface NetworksResponse {
  networks: NetworkConfig[];
}

export interface HealthResponse {
  status: 'ok' | 'error';
}

export interface ApiCapabilitiesResponse {
  protocolProfiles?: string[];
}

export interface Payment {
  paymentId: string;
  network: NetworkKey;
  resourceId: string;
  schemeId: string;
  invoiceType: string | null;
  payer: string;
  merchant: string;
  token: string;
  amount: string;
  feeAmount: string;
  reference: string | null;
  referenceHash: string | null;
  referenceBase: string | null;
  sessionId: string | null;
  timestamp: string;
  blockNumber: string | null;
  txHash: string;
  createdAt: string;
  updatedAt: string;
}

export interface PaymentsResponse {
  data: Payment[];
  page: number;
  pageSize: number;
  total: number;
  hasMore: boolean;
}

export interface PaymentsParams {
  page?: number;
  pageSize?: number;
  invoice_type?: string;
  reference?: string;
  reference_base?: string;
  resource_id?: string;
  session_id?: string;
  network?: NetworkKey;
}

export interface PaymentStatusResponse {
  status: 'pending' | 'settled';
  network?: NetworkKey;
  payment?: Payment;
}

export interface CanPayParams {
  network: NetworkKey;
  from: string;
  to: string;
  token?: string;
  amount: string;
}

export interface CanPayResponse {
  ok: boolean;
  canPay: boolean;
  reason?: string;
  token?: string;
  amountWei?: string;
}

export type BuildIntentMode = 'minimal' | 'advanced';
export type BuildIntentScheme = 'aa_push' | 'permit2' | 'eip2612' | 'eip3009';
export type PaymentScheme = BuildIntentScheme | 'push_signed' | 'session';

export interface BuildIntentMinimalRequest {
  mode: 'minimal';
  network: NetworkKey;
  merchant: string;
  token: string;
  amount: string;
  decimals?: number;
  scheme: BuildIntentScheme;
  sessionId?: string;
  payer?: string;
  deadlineSeconds?: number;
  invoiceId?: string;
  referenceId?: string;
  baseReference?: string;
  salt?: string;
}

export interface BuildIntentAdvancedRequest {
  mode?: 'advanced';
  chainId: number;
  merchant: string;
  token: string;
  amountWei: string;
  referenceId: string;
  salt: string;
  baseReference: string;
  schemeId: string;
  deadline: number;
  sessionId?: string;
  payer?: string;
}

export type BuildIntentRequest = BuildIntentMinimalRequest | BuildIntentAdvancedRequest;

export interface BuildIntentResponse {
  input: {
    chainId: number;
    merchant: string;
    token: string;
    amount: string;
    amountWei: string;
    decimals: number;
    scheme: string;
    schemeRequested?: string | null;
    deadline: number;
    sessionId: string | null;
    payer: string;
    referenceId: string;
    baseReference: string;
    salt: string;
  };
  derived: {
    resourceId: string;
    referenceDataTagged: string;
    referenceHash: string;
    paymentId: string;
    intent: {
      paymentId: string;
      merchant: string;
      token: string;
      amount: string;
      deadline: number;
      payer: string;
      resourceId: string;
      referenceHash: string;
      nonce: string;
    };
    intentHash: string;
  };
  signing: {
    routerDomain: {
      name: string;
      version: string;
      chainId: number;
      verifyingContract: string;
    };
    spendAuthTemplate?: {
      domain: {
        name: string;
        version: string;
        chainId: number;
        verifyingContract: string;
      };
      primaryType: string;
      types: Record<string, Array<{ name: string; type: string }>>;
      message: Record<string, string>;
    };
    permit2WitnessTypeString: string;
    permit2WitnessMode: 'struct_hash';
  };
  hints: {
    deadlineSecondsDefaulted: boolean;
    saltAutoGenerated: boolean;
    referenceAutoGenerated: boolean;
    canonicalReference: string;
    schemeSelected?: string;
    schemeRequested?: string | null;
    requiresBundle?: boolean | null;
  };
  paymentId?: string;
  intent?: RelayIntent;
  witness?: RelayWitness;
  deadline?: number;
  resourceId?: string;
  unsignedTx?: {
    to: string;
    data: string;
    value: string;
    chainId: number;
  };
  estimatedGas?: string;
}

export interface WalletPaymentsParams {
  page?: number;
  pageSize?: number;
  role?: 'payer' | 'merchant';
  network?: NetworkKey;
}

export interface WalletPaymentsResponse {
  data: Payment[];
  page: number;
  pageSize: number;
  total: number;
  hasMore: boolean;
}

export interface SessionTokenBudget {
  token: string;
  cap: string;
  remaining?: string;
  dailyCap?: string;
  dailySpent?: string;
  dailyWindowStart?: number;
}

export interface Session {
  sessionId: string;
  network: NetworkKey;
  payer: string;
  agent: string;
  merchantScope: string;
  expiresAt: number;
  epoch: number;
  nonce?: string;
  revoked: boolean;
  allowedSchemes?: string[];
  openedAt?: string;
  openedBlockNumber?: string;
  openedTxHash?: string;
  rateLimitMaxTxPerMinute?: number | null;
  rateLimitMaxTxPerDay?: number | null;
  rateLimitCooldown?: number | null;
  minuteWindowStart?: number | null;
  txCountInMinute?: number | null;
  dayWindowStart?: number | null;
  txCountInDay?: number | null;
  lastSpendAt?: string | null;
  tokens?: SessionTokenBudget[];
}

export interface AgentSession extends Session {
  spendNonce?: string;
}

export interface SessionsParams {
  wallet: string;
  role?: 'payer' | 'agent';
  network?: NetworkKey;
  page?: number;
  pageSize?: number;
}

export interface SessionsResponse<T = Session> {
  data: T[];
  page: number;
  pageSize: number;
  total: number;
  hasMore: boolean;
}

export interface SessionSpend {
  spendId?: string;
  sessionId: string;
  network: NetworkKey;
  agent: string;
  token: string;
  amount: string;
  schemeId: string;
  txHash: string;
  logIndex?: number | string;
  blockNumber?: string | null;
  timestamp: string;
}

export interface SessionRevocation {
  sessionId: string;
  network: NetworkKey;
  caller: string;
  epoch: number;
  txHash: string;
  logIndex?: number | string;
  blockNumber?: string | null;
  timestamp: string;
}

export interface SessionDetailsResponse {
  session: Session;
  spends: SessionSpend[];
  revocations: SessionRevocation[];
}

export interface SessionSpendsResponse {
  data: SessionSpend[];
  page: number;
  pageSize: number;
  total: number;
  hasMore: boolean;
}

export interface SessionPaymentsResponse {
  data: Payment[];
  page: number;
  pageSize: number;
  total: number;
  hasMore: boolean;
}

export interface RelayIntent {
  paymentId: string;
  merchant: string;
  token: string;
  amount: string;
  deadline: number;
  resourceId: string;
  payer?: string;
  referenceHash?: string;
  nonce?: string;
}

export interface RelayWitness {
  schemeId: string;
  intentHash: string;
  payer: string;
  salt: string;
}

export interface RelaySession {
  sessionId: string;
  agent?: string;
}

export interface RelaySessionAuth {
  sessionId: string;
  intentHash: string;
  schemeId: string;
  spendNonce: string | number;
  expiresAt: number;
  epoch: number;
}

export interface RelayPermit2 {
  permit: {
    permitted: {
      token: string;
      amount: string;
    };
    nonce: string | number;
    deadline: number | string;
  };
  transferDetails: {
    to: string;
    requestedAmount: string;
  };
  signature: string;
}

export interface RelayEip2612 {
  deadline: number;
  v: number;
  r: string;
  s: string;
}

export interface RelayEip3009 {
  validAfter: number;
  validBefore: number;
  authNonce: string;
  v: number;
  r: string;
  s: string;
}

export type RelayPaymentRequest =
  | {
      network: NetworkKey;
      scheme: 'push_signed';
      signedTx: string;
      intent: RelayIntent;
      witness: RelayWitness;
      witnessSignature: string;
      reference?: string;
      session?: RelaySession;
      sessionAuth?: RelaySessionAuth;
      sessionAuthSignature?: string;
    }
  | {
      network: NetworkKey;
      scheme: 'permit2' | 'eip2612' | 'eip3009';
      intent: RelayIntent;
      witness: RelayWitness;
      witnessSignature: string;
      reference?: string;
      session?: RelaySession;
      sessionAuth?: RelaySessionAuth;
      sessionAuthSignature?: string;
      permit2?: RelayPermit2;
      eip2612?: RelayEip2612;
      eip3009?: RelayEip3009;
    };

export interface RelayPaymentResponse {
  txHash: string;
  network: NetworkKey;
  paymentId: string;
  referenceId?: string;
}

export interface Permit2BundleRequest {
  network: NetworkKey;
  intent: RelayIntent;
  witness: RelayWitness;
  witnessSignature: string;
  reference?: string;
  session?: RelaySession;
  sessionAuth?: RelaySessionAuth;
  sessionAuthSignature?: string;
  permit2: RelayPermit2;
  approvalTx: string;
  targetBlock?: number;
  maxBlockNumber?: number;
  minTimestamp?: number;
  maxTimestamp?: number;
  topUpWei?: string;
  topUpTo?: string;
  revertingTxHashes?: string[];
}

export interface Permit2BundleResponse {
  bundleId: string;
  method: string;
  targetBlock: number;
  network: NetworkKey;
  paymentId: string;
  referenceId?: string;
}

export interface RelaySessionRevokeRequest {
  network: NetworkKey;
  sessionId: string;
  deadline: number;
  signature: string;
}

export interface RelaySessionRevokeResponse {
  txHash: string;
  sessionId: string;
  network: NetworkKey;
}

export interface SessionGrant {
  sessionId: string;
  payer: string;
  agent: string;
  merchantScope: string;
  deadline: number;
  expiresAt: number;
  epoch: number;
  nonce: string | number;
  rateLimit: {
    maxTxPerMinute: number;
    maxTxPerDay: number;
    coolDownSeconds: number;
  };
  allowedSchemes: string[];
  tokenCaps: Array<{
    token: string;
    cap: string;
    dailyCap: string;
  }>;
}

export interface ClaimableSessionGrant {
  sessionId: string;
  payer: string;
  merchantScope: string;
  deadline: number;
  expiresAt: number;
  epoch: number;
  nonce: string | number;
  claimSigner: string;
  rateLimit: {
    maxTxPerMinute: number;
    maxTxPerDay: number;
    coolDownSeconds: number;
  };
  allowedSchemes: string[];
  tokenCaps: Array<{
    token: string;
    cap: string;
    dailyCap: string;
  }>;
}

export interface RelaySessionOpenRequest {
  network: NetworkKey;
  grant: SessionGrant;
  signature: string;
}

export interface RelaySessionOpenResponse {
  txHash: string;
  sessionId: string;
  network: NetworkKey;
}

export interface RelaySessionOpenClaimableRequest {
  network: NetworkKey;
  grant: ClaimableSessionGrant;
  signature: string;
}

export interface RelaySessionOpenClaimableResponse {
  txHash: string;
  sessionId: string;
  network: NetworkKey;
}

export interface RelaySessionClaimRequest {
  network: NetworkKey;
  sessionId: string;
  agent: string;
  deadline: number;
  signature: string;
}

export interface RelaySessionClaimResponse {
  txHash: string;
  sessionId: string;
  network: NetworkKey;
}

export type InvoiceStatus = 'pending' | 'paid' | 'canceled' | 'expired';

export interface InvoiceCreateRequest {
  title: string;
  merchantId: string;
  merchantName?: string;
  merchantEmail?: string;
  payerEmail?: string;
  amount: string;
  currencyToken: string;
  network: NetworkKey;
  tokenAllowlist: string[];
  expiresAt?: string;
  reference?: string;
}

export interface Invoice {
  invoiceId: string;
  merchantId: string;
  title: string;
  merchantName?: string;
  merchantEmail?: string;
  payerEmail?: string;
  amount: string;
  currencyToken: string;
  network: NetworkKey;
  tokenAllowlist: string[];
  reference: string;
  status: InvoiceStatus;
  expiresAt?: string;
  paymentId?: string;
  resourceId?: string;
  txHash?: string;
  createdAt: string;
  updatedAt: string;
}

export interface InvoiceStatusResponse {
  invoiceId: string;
  status: InvoiceStatus;
  paymentId?: string;
  txHash?: string;
  resourceId?: string;
}

export interface ConfirmPaymentRequest {
  txHash: string;
  paymentId?: string;
  resourceId?: string;
  paidBy: string;
  paidAmount: string;
  paidToken: string;
}

export interface Token {
  symbol: string;
  address: string;
  decimals: number;
  name?: string;
  isNative?: boolean;
  tokenType?: 'native' | 'erc20';
  supportsPermit2?: boolean;
  supportsEIP2612?: boolean;
  supportsEIP3009?: boolean;
  feeOnTransfer?: boolean;
}

export interface TokensResponse {
  [network: string]: Token[];
}

export type GiftCardStatus = 'active' | 'claimed' | 'redeemed' | 'cancelled' | 'expired';
export type GiftCardType = 'direct' | 'open';

export interface GiftCard {
  cardId: string;
  cardType: GiftCardType;
  status: GiftCardStatus;
  network: NetworkKey;
  amount: string;
  token: string;
  creatorAddress: string;
  payerAddress: string;
  recipientAddress?: string | null;
  claimSigner?: string | null;
  claimedAgent?: string | null;
  sessionId?: string | null;
  paymentId?: string | null;
  txHash?: string | null;
  redeemedBy?: string | null;
  createdAt: number;
  expiresAt?: number | null;
  redeemedAt?: number | null;
  message?: string | null;
  senderName?: string | null;
  reference?: string | null;
  intentHash?: string | null;
  schemeId?: string | null;
  sessionEpoch?: number | null;
  sessionAgent?: string | null;
  sessionSpendNonce?: string | null;
  sessionExpiresAt?: number | null;
}

export interface GiftCardCreateRequest {
  network: NetworkKey;
  cardType: GiftCardType;
  amount: string;
  token: string;
  creator: string;
  recipient?: string;
  senderName?: string;
  message?: string;
  expiresAt?: number;
  payment: {
    intent: RelayIntent;
    witness: RelayWitness;
    witnessSignature: string;
    reference?: string;
    scheme: 'permit2' | 'eip2612' | 'eip3009';
    permit: RelayPermit2 | RelayEip2612 | RelayEip3009;
  };
  session?: {
    grant: ClaimableSessionGrant;
    signature: string;
  };
}

export interface GiftCardCreateResponse {
  card: GiftCard;
  accessCode?: string | null;
  sessionId?: string | null;
  sessionOpenTxHash?: string | null;
}

export interface GiftCardClaimRequest {
  cardId: string;
  agent: string;
  deadline: number;
  signature: string;
}

export interface GiftCardRedeemRequest {
  cardId: string;
  redeemer: string;
  accessCode?: string;
  sessionAuth?: RelaySessionAuth;
  sessionAuthSignature?: string;
}

export interface GiftCardRedeemResponse extends GiftCard {
  paymentId?: string;
  txHash?: string;
}

export interface GiftCardListParams {
  wallet?: string;
  role?: 'creator' | 'recipient' | 'claimer' | 'all';
  network?: NetworkKey;
  status?: GiftCardStatus;
  page?: number;
  pageSize?: number;
}

export interface GiftCardListResponse {
  data: GiftCard[];
  page: number;
  pageSize: number;
  total: number;
  hasMore: boolean;
}

export interface ApiError {
  message?: string;
  error?: string;
  code?: string;
  details?: Record<string, unknown>;
}

export class BnbpayApiError extends Error {
  public readonly statusCode: number;
  public readonly details?: ApiError;

  constructor(message: string, statusCode: number, details?: ApiError) {
    super(message);
    this.name = 'BnbpayApiError';
    this.statusCode = statusCode;
    this.details = details;
  }
}

export interface ApiClientOptions {
  baseUrl?: string;
  apiKey?: string;
  headers?: Record<string, string>;
  fetchFn?: typeof fetch;
}

export interface ApiRequestOptions {
  signal?: AbortSignal;
  headers?: Record<string, string>;
}

export function serializeBigInt(value: unknown): unknown {
  if (value === null || value === undefined) return value;
  if (typeof value === 'bigint') return value.toString();
  if (Array.isArray(value)) return value.map(serializeBigInt);
  if (typeof value === 'object') {
    const result: Record<string, unknown> = {};
    for (const [key, entry] of Object.entries(value)) {
      result[key] = serializeBigInt(entry);
    }
    return result;
  }
  return value;
}

export function safeStringify(value: unknown, space?: number): string {
  return JSON.stringify(serializeBigInt(value), null, space);
}

function buildUrl(
  baseUrl: string,
  path: string,
  query?: Record<string, string | number | boolean | undefined>
): string {
  const url = new URL(path, baseUrl);
  if (query) {
    Object.entries(query).forEach(([key, val]) => {
      if (val === undefined || val === null || val === '') return;
      url.searchParams.set(key, String(val));
    });
  }
  return url.toString();
}

function buildWsUrl(baseUrl: string, path: string): string {
  const url = new URL(path, baseUrl);
  url.protocol = url.protocol === 'https:' ? 'wss:' : 'ws:';
  return url.toString();
}

function splitOptions<T extends object>(params?: T & ApiRequestOptions) {
  if (!params) {
    return { query: undefined, options: undefined };
  }
  const { signal, headers, ...query } = params as ApiRequestOptions & Record<string, unknown>;
  const options = signal || headers ? { signal, headers } : undefined;
  return {
    query: query as Record<string, string | number | boolean | undefined>,
    options,
  };
}

async function requestJson<T>(
  fetchFn: typeof fetch,
  url: string,
  options: RequestInit
): Promise<T> {
  const response = await fetchFn(url, options);
  if (!response.ok) {
    let errorDetails: ApiError | undefined;
    let errorText: string | undefined;
    try {
      const text = await response.text();
      errorText = text;
      errorDetails = JSON.parse(text) as ApiError;
    } catch {
      // fall through
    }
    throw new BnbpayApiError(
      errorDetails?.message || errorDetails?.error || errorText || `HTTP ${response.status}: ${response.statusText}`,
      response.status,
      errorDetails
    );
  }
  return response.json() as Promise<T>;
}

export interface ApiClient {
  health: () => Promise<HealthResponse>;
  getCapabilities: () => Promise<ApiCapabilitiesResponse | undefined>;
  networks: () => Promise<NetworksResponse>;
  tokens: () => Promise<TokensResponse>;
  getNetworkByChainId: (chainId: number) => Promise<NetworkConfig | undefined>;
  getNetworkByKey: (key: NetworkKey) => Promise<NetworkConfig | undefined>;
  getTokensByNetwork: (network: NetworkKey) => Promise<Token[]>;
  getTokenCapabilities: (symbol: string, network: NetworkKey) => Promise<Token | undefined>;
  payments: {
    list: (params?: PaymentsParams & ApiRequestOptions) => Promise<PaymentsResponse>;
    get: (paymentId: string, options?: ApiRequestOptions) => Promise<Payment>;
    status: (
      paymentId: string,
      params?: { network?: NetworkKey } & ApiRequestOptions
    ) => Promise<PaymentStatusResponse>;
    canPay: (params: CanPayParams & ApiRequestOptions) => Promise<CanPayResponse>;
    buildIntent: (request: BuildIntentRequest, options?: ApiRequestOptions) => Promise<BuildIntentResponse>;
  };
  wallets: {
    payments: (
      address: string,
      params?: WalletPaymentsParams & ApiRequestOptions
    ) => Promise<WalletPaymentsResponse>;
  };
  sessions: {
    list: (params: SessionsParams & ApiRequestOptions) => Promise<SessionsResponse>;
    listByAgent: (
      address: string,
      params?: { network: NetworkKey; page?: number; pageSize?: number } & ApiRequestOptions
    ) => Promise<SessionsResponse<AgentSession>>;
    get: (sessionId: string, options?: ApiRequestOptions) => Promise<SessionDetailsResponse>;
    spends: (
      sessionId: string,
      params?: { page?: number; pageSize?: number } & ApiRequestOptions
    ) => Promise<SessionSpendsResponse>;
    payments: (
      sessionId: string,
      params?: { page?: number; pageSize?: number } & ApiRequestOptions
    ) => Promise<SessionPaymentsResponse>;
  };
  invoices: {
    create: (request: InvoiceCreateRequest, options?: ApiRequestOptions) => Promise<Invoice>;
    get: (invoiceId: string, options?: ApiRequestOptions) => Promise<Invoice>;
    status: (invoiceId: string, options?: ApiRequestOptions) => Promise<InvoiceStatusResponse>;
    cancel: (invoiceId: string, options?: ApiRequestOptions) => Promise<Invoice>;
    confirmPayment: (
      invoiceId: string,
      payload: ConfirmPaymentRequest,
      options?: ApiRequestOptions
    ) => Promise<Invoice>;
    streamSseUrl: (invoiceId: string) => string;
    streamWsUrl: (invoiceId: string) => string;
  };
  relay: {
    payment: (request: RelayPaymentRequest, options?: ApiRequestOptions) => Promise<RelayPaymentResponse>;
    permit2Bundle: (request: Permit2BundleRequest, options?: ApiRequestOptions) => Promise<Permit2BundleResponse>;
    sessionRevoke: (request: RelaySessionRevokeRequest, options?: ApiRequestOptions) => Promise<RelaySessionRevokeResponse>;
    sessionOpen: (request: RelaySessionOpenRequest, options?: ApiRequestOptions) => Promise<RelaySessionOpenResponse>;
    sessionOpenClaimable: (
      request: RelaySessionOpenClaimableRequest,
      options?: ApiRequestOptions
    ) => Promise<RelaySessionOpenClaimableResponse>;
    sessionClaim: (request: RelaySessionClaimRequest, options?: ApiRequestOptions) => Promise<RelaySessionClaimResponse>;
  };
  giftcards: {
    create: (request: GiftCardCreateRequest, options?: ApiRequestOptions) => Promise<GiftCardCreateResponse>;
    claim: (request: GiftCardClaimRequest, options?: ApiRequestOptions) => Promise<GiftCard>;
    redeem: (request: GiftCardRedeemRequest, options?: ApiRequestOptions) => Promise<GiftCardRedeemResponse>;
    cancel: (cardId: string, options?: ApiRequestOptions) => Promise<GiftCard>;
    get: (cardId: string, options?: ApiRequestOptions) => Promise<GiftCard>;
    list: (params?: GiftCardListParams & ApiRequestOptions) => Promise<GiftCardListResponse>;
  };
}

export function createApiClient(options: ApiClientOptions = {}): ApiClient {
  const baseUrl = options.baseUrl ?? DEFAULT_API_BASE_URL;
  const fetchFn = options.fetchFn ?? fetch;
  if (!fetchFn) {
    throw new Error('fetch implementation is required');
  }

  const baseHeaders: Record<string, string> = {
    ...(options.headers ?? {}),
  };
  if (options.apiKey) {
    baseHeaders['x-api-key'] = options.apiKey;
  }

  const request = async <T>(
    path: string,
    method: string,
    body?: unknown,
    query?: Record<string, string | number | boolean | undefined>,
    requestOptions?: ApiRequestOptions
  ): Promise<T> => {
    const headers: Record<string, string> = {
      ...baseHeaders,
      ...(requestOptions?.headers ?? {}),
    };
    const init: RequestInit = {
      method,
      headers,
      signal: requestOptions?.signal,
    };
    if (body !== undefined) {
      headers['content-type'] = 'application/json';
      init.body = safeStringify(body);
    }
    const url = buildUrl(baseUrl, path, query);
    return requestJson<T>(fetchFn, url, init);
  };

  return {
    health: () => request<HealthResponse>('/health', 'GET'),
    getCapabilities: async () => {
      try {
        return await request<ApiCapabilitiesResponse>('/x402/capabilities', 'GET');
      } catch (error) {
        if (
          error instanceof BnbpayApiError
          && (error.statusCode === 404 || error.statusCode === 501)
        ) {
          return undefined;
        }
        throw error;
      }
    },
    networks: () => request<NetworksResponse>('/networks', 'GET'),
    tokens: () => request<TokensResponse>('/tokens', 'GET'),
    getNetworkByChainId: async (chainId: number) => {
      const { networks } = await request<NetworksResponse>('/networks', 'GET');
      return networks.find((network) => network.chainId === chainId);
    },
    getNetworkByKey: async (key: NetworkKey) => {
      const { networks } = await request<NetworksResponse>('/networks', 'GET');
      return networks.find((network) => network.key === key);
    },
    getTokensByNetwork: async (network: NetworkKey) => {
      const tokens = await request<TokensResponse>('/tokens', 'GET');
      return tokens[network] || [];
    },
    getTokenCapabilities: async (symbol: string, network: NetworkKey) => {
      const tokens = await request<TokensResponse>('/tokens', 'GET');
      const list = tokens[network] || [];
      return list.find((token) => token.symbol.toUpperCase() === symbol.toUpperCase());
    },
    payments: {
      list: (params) => {
        const { query, options } = splitOptions(params);
        return request<PaymentsResponse>('/payments', 'GET', undefined, query, options);
      },
      get: (paymentId, opts) =>
        request<Payment>(`/payments/${paymentId}`, 'GET', undefined, undefined, opts),
      status: (paymentId, params) => {
        const { query, options } = splitOptions(params);
        return request<PaymentStatusResponse>(`/payments/${paymentId}/status`, 'GET', undefined, query, options);
      },
      canPay: async (params) => {
        const { query, options } = splitOptions(params);
        const response = await request<{ ok: boolean; reason?: string; token?: string; amountWei?: string }>(
          '/can-pay',
          'GET',
          undefined,
          query,
          options
        );
        return {
          ...response,
          canPay: response.ok,
        };
      },
      buildIntent: (payload, opts) => request<BuildIntentResponse>('/payments/build-intent', 'POST', payload, undefined, opts),
    },
    wallets: {
      payments: (address, params) => {
        const { query, options } = splitOptions(params);
        return request<WalletPaymentsResponse>(
          `/wallets/${address}/payments`,
          'GET',
          undefined,
          query,
          options
        );
      },
    },
    sessions: {
      list: (params) => {
        const { query, options } = splitOptions(params);
        return request<SessionsResponse>('/sessions', 'GET', undefined, query, options);
      },
      listByAgent: (address, params) => {
        const { query, options } = splitOptions(params);
        return request<SessionsResponse<AgentSession>>(
          `/sessions/agent/${address}`,
          'GET',
          undefined,
          query,
          options
        );
      },
      get: (sessionId, opts) =>
        request<SessionDetailsResponse>(`/sessions/${sessionId}`, 'GET', undefined, undefined, opts),
      spends: (sessionId, params) => {
        const { query, options } = splitOptions(params);
        return request<SessionSpendsResponse>(
          `/sessions/${sessionId}/spends`,
          'GET',
          undefined,
          query,
          options
        );
      },
      payments: (sessionId, params) => {
        const { query, options } = splitOptions(params);
        return request<SessionPaymentsResponse>(
          `/sessions/${sessionId}/payments`,
          'GET',
          undefined,
          query,
          options
        );
      },
    },
    invoices: {
      create: (payload, opts) => request<Invoice>('/invoices', 'POST', payload, undefined, opts),
      get: (invoiceId, opts) => request<Invoice>(`/invoices/${invoiceId}`, 'GET', undefined, undefined, opts),
      status: (invoiceId, opts) =>
        request<InvoiceStatusResponse>(`/invoices/${invoiceId}/status`, 'GET', undefined, undefined, opts),
      cancel: (invoiceId, opts) =>
        request<Invoice>(`/invoices/${invoiceId}/cancel`, 'POST', undefined, undefined, opts),
      confirmPayment: (invoiceId, payload, opts) =>
        request<Invoice>(`/invoices/${invoiceId}/confirm-payment`, 'POST', payload, undefined, opts),
      streamSseUrl: (invoiceId) => buildUrl(baseUrl, `/invoices/${invoiceId}/stream-sse`),
      streamWsUrl: (invoiceId) => buildWsUrl(baseUrl, `/invoices/${invoiceId}/stream`),
    },
    relay: {
      payment: (payload, opts) => request<RelayPaymentResponse>('/relay/payment', 'POST', payload, undefined, opts),
      permit2Bundle: (payload, opts) =>
        request<Permit2BundleResponse>('/relay/permit2/bundle', 'POST', payload, undefined, opts),
      sessionRevoke: (payload, opts) =>
        request<RelaySessionRevokeResponse>('/relay/session/revoke', 'POST', payload, undefined, opts),
      sessionOpen: (payload, opts) =>
        request<RelaySessionOpenResponse>('/relay/session/open', 'POST', payload, undefined, opts),
      sessionOpenClaimable: (payload, opts) =>
        request<RelaySessionOpenClaimableResponse>(
          '/relay/session/open-claimable',
          'POST',
          payload,
          undefined,
          opts
        ),
      sessionClaim: (payload, opts) =>
        request<RelaySessionClaimResponse>('/relay/session/claim', 'POST', payload, undefined, opts),
    },
    giftcards: {
      create: (payload, opts) => request<GiftCardCreateResponse>('/giftcards/create', 'POST', payload, undefined, opts),
      claim: (payload, opts) => request<GiftCard>('/giftcards/claim', 'POST', payload, undefined, opts),
      redeem: (payload, opts) => request<GiftCardRedeemResponse>('/giftcards/redeem', 'POST', payload, undefined, opts),
      cancel: (cardId, opts) => request<GiftCard>(`/giftcards/${cardId}/cancel`, 'POST', undefined, undefined, opts),
      get: (cardId, opts) => request<GiftCard>(`/giftcards/${cardId}`, 'GET', undefined, undefined, opts),
      list: (params) => {
        const { query, options } = splitOptions(params);
        return request<GiftCardListResponse>('/giftcards', 'GET', undefined, query, options);
      },
    },
  };
}
